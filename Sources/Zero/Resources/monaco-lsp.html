<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        html, body { height: 100%; overflow: hidden; background: #1e1e1e; }
        #editor { width: 100%; height: 100%; }
        #status { 
            position: fixed; 
            bottom: 0; 
            right: 0; 
            padding: 4px 8px; 
            background: #007acc; 
            color: white; 
            font-size: 12px;
            display: none;
        }
        #status.connected { display: block; background: #4caf50; }
        #status.disconnected { display: block; background: #f44336; }
    </style>
</head>
<body>
    <div id="editor"></div>
    <div id="status">LSP</div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.45.0/min/vs/loader.min.js"></script>
    <script>
        let editor;
        let lspSocket = null;
        let lspEnabled = false;
        let lspConnected = false;
        let requestId = 0;
        const pendingRequests = new Map();
        let reconnectTimer = null;
        let currentDocumentPath = '/workspace/Main.java';
        let currentLanguage = 'java';
        let documentVersion = 1;
        let didOpenSent = false;

        // LSP Message Types
        const LSP_METHODS = {
            INITIALIZE: 'initialize',
            COMPLETION: 'textDocument/completion',
            DID_OPEN: 'textDocument/didOpen',
            DID_CHANGE: 'textDocument/didChange'
        };

        function postToNative(name, payload) {
            try {
                if (window.webkit && window.webkit.messageHandlers && window.webkit.messageHandlers[name]) {
                    window.webkit.messageHandlers[name].postMessage(payload);
                }
            } catch (_) {}
        }

        function normalizePath(path) {
            if (!path || path.trim() === '') {
                return '/workspace/Main.java';
            }

            if (path.startsWith('file://')) {
                const decoded = decodeURI(path.replace('file://', ''));
                return decoded.startsWith('/') ? decoded : `/${decoded}`;
            }

            return path.startsWith('/') ? path : `/${path}`;
        }

        function getDocumentURI() {
            return `file://${encodeURI(normalizePath(currentDocumentPath))}`;
        }

        function setStatus(text, stateClass) {
            const statusEl = document.getElementById('status');
            statusEl.className = stateClass;
            statusEl.textContent = `LSP ${text}`;
            postToNative('lspStatus', text);
        }

        function scheduleReconnect() {
            if (!lspEnabled || reconnectTimer) {
                return;
            }

            reconnectTimer = setTimeout(() => {
                reconnectTimer = null;
                if (lspEnabled) {
                    connectLSP();
                }
            }, 1500);
        }

        require.config({ paths: { vs: 'https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.45.0/min/vs' } });
        require(['vs/editor/editor.main'], function () {
            editor = monaco.editor.create(document.getElementById('editor'), {
                value: '',
                language: currentLanguage,
                theme: 'vs-dark',
                fontSize: 14,
                minimap: { enabled: true },
                automaticLayout: true,
                quickSuggestions: true,
                suggestOnTriggerCharacters: true,
                acceptSuggestionOnEnter: 'on'
            });
            
            // Notify native app that editor is ready
            postToNative('editorReady', 'ready');

            // Content change listener
            editor.onDidChangeModelContent(() => {
                const value = editor.getValue();
                postToNative('contentChanged', value);

                // Send LSP didChange notification if connected
                if (lspEnabled && lspSocket && didOpenSent) {
                    sendDidChange(value);
                }
            });

            editor.onDidChangeCursorPosition((event) => {
                postToNative('cursorChanged', {
                    line: event.position.lineNumber,
                    column: event.position.column
                });
            });

            // Setup LSP completion provider
            setupLSPCompletion();
        });

        // Connect to LSP WebSocket
        function connectLSP() {
            if (!lspEnabled) {
                return;
            }

            if (lspSocket && lspSocket.readyState === WebSocket.OPEN) {
                return;
            }

            setStatus('Connecting...', 'disconnected');

            lspSocket = new WebSocket('ws://localhost:8080');

            lspSocket.onopen = async () => {
                lspConnected = true;
                setStatus('Connected', 'connected');

                try {
                    await sendLSPRequest(LSP_METHODS.INITIALIZE, {
                        processId: null,
                        rootUri: 'file:///workspace',
                        capabilities: {
                            textDocument: {
                                completion: { dynamicRegistration: false },
                                hover: { dynamicRegistration: false }
                            }
                        }
                    });

                    sendDidOpen();
                } catch (_) {
                    setStatus('Init Failed', 'disconnected');
                    lspConnected = false;
                    didOpenSent = false;
                    if (lspSocket) {
                        lspSocket.close();
                    }
                }
            };

            lspSocket.onmessage = (event) => {
                try {
                    const message = JSON.parse(event.data);
                    handleLSPMessage(message);
                } catch (_) {
                    // Ignore malformed message
                }
            };

            lspSocket.onclose = () => {
                lspConnected = false;
                lspSocket = null;
                didOpenSent = false;
                setStatus('Disconnected', 'disconnected');
                scheduleReconnect();
            };

            lspSocket.onerror = () => {
                lspConnected = false;
                setStatus('Error', 'disconnected');
                scheduleReconnect();
            };
        }

        function sendDidOpen() {
            if (!lspConnected || !lspSocket || !editor) {
                return;
            }

            documentVersion = 1;
            didOpenSent = true;

            sendLSPNotification(LSP_METHODS.DID_OPEN, {
                textDocument: {
                    uri: getDocumentURI(),
                    languageId: currentLanguage,
                    version: documentVersion,
                    text: editor.getValue()
                }
            });
        }

        function sendDidChange(text) {
            if (!lspConnected || !lspSocket || !didOpenSent) {
                return;
            }

            documentVersion += 1;

            sendLSPNotification(LSP_METHODS.DID_CHANGE, {
                textDocument: {
                    uri: getDocumentURI(),
                    version: documentVersion
                },
                contentChanges: [
                    {
                        text
                    }
                ]
            });
        }

        // Setup LSP-based completion
        function setupLSPCompletion() {
            // Register completion provider for Java
            monaco.languages.registerCompletionItemProvider('java', {
                triggerCharacters: ['.', ':'],
                provideCompletionItems: async (model, position) => {
                    if (!lspConnected || !lspSocket) {
                        // Fallback to basic suggestions
                        return { suggestions: [] };
                    }

                    try {
                        const result = await sendLSPRequest(LSP_METHODS.COMPLETION, {
                            textDocument: { uri: getDocumentURI() },
                            position: {
                                line: position.lineNumber - 1,
                                character: position.column - 1
                            }
                        });

                        const items = Array.isArray(result)
                            ? result
                            : (result && Array.isArray(result.items) ? result.items : []);

                        if (items.length > 0) {
                            const suggestions = items.map(item => ({
                                label: item.label,
                                kind: mapCompletionItemKind(item.kind),
                                detail: item.detail,
                                documentation: item.documentation,
                                insertText: item.insertText || item.label,
                                range: {
                                    startLineNumber: position.lineNumber,
                                    startColumn: position.column,
                                    endLineNumber: position.lineNumber,
                                    endColumn: position.column
                                }
                            }));
                            
                            return { suggestions };
                        }
                    } catch (_) {
                        // Ignore completion failures and fallback to empty list
                    }

                    return { suggestions: [] };
                }
            });
        }
        
        // Send LSP request
        function sendLSPRequest(method, params) {
            return new Promise((resolve, reject) => {
                if (!lspSocket || lspSocket.readyState !== WebSocket.OPEN) {
                    reject(new Error('LSP socket is not connected'));
                    return;
                }

                const id = ++requestId;
                pendingRequests.set(id, { resolve, reject });

                const message = { jsonrpc: '2.0', id, method, params };
                lspSocket.send(JSON.stringify(message));
                
                // Timeout after 5 seconds
                setTimeout(() => {
                    if (pendingRequests.has(id)) {
                        pendingRequests.delete(id);
                        reject(new Error('LSP request timeout'));
                    }
                }, 5000);
            });
        }

        // Send LSP notification
        function sendLSPNotification(method, params) {
            if (!lspSocket || lspSocket.readyState !== WebSocket.OPEN) {
                return;
            }

            const message = { jsonrpc: '2.0', method, params };
            lspSocket.send(JSON.stringify(message));
        }

        // Handle LSP response
        function handleLSPMessage(message) {
            if (message.id !== undefined && pendingRequests.has(message.id)) {
                const { resolve, reject } = pendingRequests.get(message.id);
                pendingRequests.delete(message.id);
                
                if (message.error) {
                    reject(message.error);
                } else {
                    resolve(message.result);
                }
            }
        }
        
        // Map LSP completion item kind to Monaco
        function mapCompletionItemKind(kind) {
            const kinds = [
                monaco.languages.CompletionItemKind.Text,
                monaco.languages.CompletionItemKind.Method,
                monaco.languages.CompletionItemKind.Function,
                monaco.languages.CompletionItemKind.Constructor,
                monaco.languages.CompletionItemKind.Field,
                monaco.languages.CompletionItemKind.Variable,
                monaco.languages.CompletionItemKind.Class,
                monaco.languages.CompletionItemKind.Interface,
                monaco.languages.CompletionItemKind.Module,
                monaco.languages.CompletionItemKind.Property,
                monaco.languages.CompletionItemKind.Unit,
                monaco.languages.CompletionItemKind.Value,
                monaco.languages.CompletionItemKind.Enum,
                monaco.languages.CompletionItemKind.Keyword,
                monaco.languages.CompletionItemKind.Snippet,
                monaco.languages.CompletionItemKind.Color,
                monaco.languages.CompletionItemKind.File,
                monaco.languages.CompletionItemKind.Reference
            ];
            return kinds[kind] || monaco.languages.CompletionItemKind.Text;
        }

        // External functions called from Swift
        function setContent(content, language) {
            currentLanguage = language || currentLanguage || 'java';

            if (editor) {
                monaco.editor.setModelLanguage(editor.getModel(), currentLanguage);
                if (editor.getValue() !== content) {
                    editor.setValue(content);
                }
            }

            if (lspConnected && didOpenSent && editor) {
                sendDidChange(editor.getValue());
            }
        }

        function setLanguage(language) {
            currentLanguage = language || 'java';

            if (editor) {
                monaco.editor.setModelLanguage(editor.getModel(), currentLanguage);
            }

            if (lspConnected && didOpenSent) {
                sendDidOpen();
            }
        }

        function setDocumentPath(path) {
            const nextPath = normalizePath(path);
            if (nextPath === currentDocumentPath) {
                return;
            }

            currentDocumentPath = nextPath;
            documentVersion = 1;

            if (lspConnected && editor) {
                sendDidOpen();
            }
        }

        function getContent() {
            return editor ? editor.getValue() : '';
        }

        function enableLSP() {
            lspEnabled = true;
            connectLSP();
        }

        function disableLSP() {
            lspEnabled = false;
            lspConnected = false;

            if (reconnectTimer) {
                clearTimeout(reconnectTimer);
                reconnectTimer = null;
            }

            if (lspSocket) {
                lspSocket.close();
            }

            lspSocket = null;
            didOpenSent = false;
            setStatus('Disconnected', 'disconnected');
        }
    </script>
</body>
</html>
